---
title: 'Fase 2: Clustering'
author: "Irving, Chuy"
date: "2025-02-10"
output: html_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
library(dplyr)
library(kableExtra)
library(tidyr)
library(ggplot2)

library(hopkins)
library(lubridate)
library(factoextra)
```

```{r, include=FALSE}
movies <- read.csv("./movies.csv")

```

## 1.1 Seleccion de columnas
```{r echo=FALSE}
columns <- c("id", "popularity", "budget", "revenue", "runtime", "genresAmount", "productionCountriesAmount", "releaseDate", "voteCount", "voteAvg", "actorsPopularity", "actorsAmount", "castWomenAmount", "castMenAmount")

selected_movies_clustr <- movies[,columns]

selected_movies_clustr

```

# Conversion de columnas no numericas
```{r echo=FALSE}
pupoular_sum <- selected_movies_clustr %>%
  separate_rows( actorsPopularity, sep = "|") %>%
  mutate(actorsPopularity = as.numeric(actorsPopularity)) %>%
  group_by(id) %>%
  summarise(totalActorPopularity = sum(actorsPopularity, na.rm = TRUE))

pupoular_sum

df_final <- selected_movies_clustr %>%
  left_join(pupoular_sum, by = "id")

df_final <- df_final %>% select(-actorsPopularity)

df_final$releaseDate <- as.Date(df_final$releaseDate, format = "%d/%m/%Y")

df_final$year <- year(df_final$releaseDate)
df_final$month <- month(df_final$releaseDate)
df_final$day <- day(df_final$releaseDate)

df_final <- df_final %>% select(-releaseDate)
df_final <- df_final %>% select(-id)


# columnas que se deben pasar a char

# data filtering
df_final <- df_final %>%
  mutate(
    castWomenAmount = ifelse(grepl("^[0-9]+$", castWomenAmount), as.integer(castWomenAmount), NA),
    castMenAmount = ifelse(grepl("^[0-9]+$", castMenAmount), as.integer(castMenAmount), NA)
  )

# Replace remaining NA values with 0
df_final$castWomenAmount[is.na(df_final$castWomenAmount)] <- 0
df_final$castMenAmount[is.na(df_final$castMenAmount)] <- 0


df_final
```
## Escalado de los datos
Es importante escalar los datos antes de realizar agrupamientos cuando se utilizan tecnicas de aprendizaje no supervisado como lo es el clustering. Dentro del data set tenemos unicamente vlores numericos, entonces podemos escalarlos para que el agrupamiento funcione mejor.

```{r echo=FALSE}
# Comentado de momento, escalar los datos impide que se vea el grafico de codo bien
# df_final <- scale(df_final)
# colSums(is.na(df_final))
```

## Estadistico de Hopkins 

Es importante saber si es plausible hacer un agrupamiento de datos con la data frame que tenemos. Para ello hemos decidido utilizar el estadistico de hopkins
```{r echo=FALSE}
set.seed(123)
hopkins(df_final)
```
Como se puede observar el data set tiene bastante potencial para hacer grupos.Es raro que los datos esten tan bien relacionados (el valor fue de 1) pero si probamos revolviendo los datos de igual manera se obtiene un numero cercano a 1. Lo cual implica que los datos pueden agruparse bastante bien

```{r echo=FALSE}
set.seed(123)
df_shuffled <- df_final[sample(nrow(df_final)), ]
hopkins(df_shuffled)
```
Con esto practicamente nos aseguramos de que nuestros datos pueden ser agrupados exitosamente. Antes de proceder con la definicion de grupos, haremos un un VAT (Evaluacion visual de tendencia por sus siglas en ingles). Este metodo grafico ayudara a corroborar el estdistico de hopkins de manera visual. Si se ve un patron visible y no aleatorio eso quiere decir que nuevamente los datos son adecuados para agruparse. Nota: Tomamos una muestra aleatorio del data set con el fin de ahorrar recursos computacionales. EL dataset tiene 10000 lineas, por lo que tomar el data set completo tomaria demasiado tiempo

```{r echo=FALSE}
set.seed(123)
sampled_df <- df_final[sample(nrow(df_final), 1000), ]  # muestra
dist_matrix <- dist(sampled_df)
fviz_dist(dist_matrix, show_labels = FALSE)

```

Puede observarse un patron visible, por lo que podemos decir que en efecto la data que tenemos puede ser agrupada. Puede que se vea un poco opaco, pero esto ocurre debido a que realmente no estamos usando la totalidad de los datos. Ahora que ya hemos confirmado que podemos agrupar, hay que definir la cantidad de grupos que deseamos hacer mediante el clustering. El numero de grupos lo obtendremos mediante el grafico de codo.

## Grafico de codo
``` {r echo=FALSE}
wss=0

wss <- sapply(1:10, function(i) sum(kmeans(df_final, centers = i)$withinss))

# Graficando el codo
plot(1:10, wss, type = "b", pch = 19, col = "blue", 
     xlab = "Número de Clusters", ylab = "Suma de cuadrados dentro de los grupos",
     main = "Método del Codo")

```

